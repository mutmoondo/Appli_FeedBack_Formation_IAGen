import os
from pathlib import Path
import sys

# Vérifier la version de Python (pathlib.Path.touch ajouté en 3.5, certaines méthodes améliorées plus tard)
if sys.version_info < (3, 5):
    print("Ce script nécessite Python 3.5 ou une version ultérieure.")
    sys.exit(1)

# Définit le chemin de base comme étant le répertoire courant
base_path = Path('.')

# --- Répertoires à créer ---
# Utilise un set pour éviter les doublons et faciliter l'ajout
# Inclut les dossiers que firebase init crée normalement, au cas où.
dirs_to_create = {
    base_path / 'public' / 'assets' / 'icons',
    base_path / 'public' / 'css',
    base_path / 'public' / 'js',
    base_path / 'functions' # Assure que le dossier functions existe
}

print("Création/Vérification des répertoires...")
for dir_path in dirs_to_create:
    try:
        # parents=True crée les dossiers parents si nécessaire
        # exist_ok=True ne lève pas d'erreur si le dossier existe déjà
        dir_path.mkdir(parents=True, exist_ok=True)
        print(f"  [OK] Répertoire : {dir_path}")
    except OSError as e:
        print(f"  [Erreur] Création répertoire {dir_path}: {e}")

# --- Fichiers à créer (s'ils n'existent pas) ---
# Inclut certains fichiers que firebase init pourrait créer, pour être sûr
files_to_create_with_content = {
    base_path / '.gitignore': """# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
functions/node_modules/ # Ignore node_modules dans functions aussi
jspm_packages/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.*.local
.env.local

# parcel-bundler cache files
.cache

# Mac files
.DS_Store

# Firebase
.firebase/emulators/**
*.firebase.log
""",
    base_path / 'firestore.rules': """rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // ATTENTION: Règles par défaut très ouvertes (permet lecture/écriture à tous).
    // TODO: Sécurisez ces règles avant la production !
    match /{document=**} {
      allow read, write: if true; // À CHANGER !
    }
  }
}
""",
    base_path / 'README.md': """# Mon Projet PWA Feedback

Ceci est une application web progressive permettant aux stagiaires de donner un feedback en temps réel pendant une formation.

## Setup

1.  Installer [Node.js](https://nodejs.org/) (qui inclut npm).
2.  Installer Firebase CLI: `npm install -g firebase-tools`
3.  Se connecter à Firebase: `firebase login`
4.  Initialiser Firebase (si pas déjà fait): `firebase init` (choisir Hosting, Functions, Firestore, Emulators)
5.  Installer les dépendances pour les Cloud Functions: `cd functions && npm install && cd ..`

## Développement Local (avec Émulateurs Firebase)

1.  Lancer les émulateurs: `firebase emulators:start`
2.  Ouvrir l'application dans le navigateur (l'URL sera indiquée, souvent http://localhost:5000)

## Déploiement

1.  Déployer les Cloud Functions: `firebase deploy --only functions`
2.  Déployer le site statique (Hosting): `firebase deploy --only hosting`
3.  Déployer les règles Firestore: `firebase deploy --only firestore:rules`
""",
    base_path / 'public' / 'manifest.json': """{
  "short_name": "Feedback",
  "name": "Feedback Formation PWA",
  "description": "Application de feedback en temps réel pour formations.",
  "icons": [
    {
      "src": "assets/icons/icon-192x192.png",
      "type": "image/png",
      "sizes": "192x192",
      "purpose": "any maskable"
    },
    {
      "src": "assets/icons/icon-512x512.png",
      "type": "image/png",
      "sizes": "512x512",
      "purpose": "any maskable"
    }
  ],
  "start_url": "/index.html",
  "display": "standalone",
  "scope": "/",
  "theme_color": "#3498db",
  "background_color": "#ffffff"
}
""",
    # Fichiers HTML de base
    base_path / 'public' / 'index.html': """<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accueil - Feedback App</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3498db"/>
</head>
<body>
    <h1>Accueil Feedback App</h1>
    <p>Entrez un ID de session pour rejoindre :</p>
    <input type="text" id="sessionInput" placeholder="ID Session">
    <button onclick="joinSession()">Rejoindre</button>

    <h2>Liens directs (pour test)</h2>
    <p><a href="trainee.html?session=test1">Page Stagiaire (session 'test1')</a></p>
    <p><a href="trainer.html?session=test1">Page Formateur (session 'test1')</a></p>

    <script>
        // Enregistrer le Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
        function joinSession() {
            const sessionId = document.getElementById('sessionInput').value.trim();
            if (sessionId) {
                // Rediriger vers la page stagiaire (ou proposer choix ?)
                window.location.href = `/trainee.html?session=${encodeURIComponent(sessionId)}`;
            } else {
                alert('Veuillez entrer un ID de session.');
            }
        }
    </script>
</body>
</html>
""",
    base_path / 'public' / 'trainee.html': """<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feedback Stagiaire</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3498db"/>
</head>
<body>
    <h1>Votre ressenti ?</h1>
    <div id="feedback-container">
        <button class="feedback-button green" data-color="green">Tout va bien</button>
        <button class="feedback-button orange" data-color="orange">Mitigé / Question</button>
        <button class="feedback-button red" data-color="red">Je suis perdu</button>
    </div>
    <p id="status"></p>

    <script src="js/trainee.js"></script>
</body>
</html>
""",
    base_path / 'public' / 'trainer.html': """<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Formateur</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3498db"/>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>Dashboard Session <span id="sessionId"></span></h1>
    <div id="chart-container" style="width: 80%; max-width: 400px; margin: auto;">
        <canvas id="feedbackChart"></canvas>
    </div>
    <div id="counters">
        <p>Votes Verts: <span id="count-green">0</span></p>
        <p>Votes Oranges: <span id="count-orange">0</span></p>
        <p>Votes Rouges: <span id="count-red">0</span></p>
        <hr>
        <p>Total Votants: <span id="count-voters">0</span></p>
        </div>

    <script src="/__/firebase/9.x.x/firebase-app-compat.js"></script> <script src="/__/firebase/9.x.x/firebase-firestore-compat.js"></script>
    <script src="/__/firebase/init.js"></script> <script src="js/trainer.js"></script>
</body>
</html>
""",
    # Fichiers vides (ou quasi)
    base_path / 'public' / 'css' / 'style.css': """body { font-family: sans-serif; padding: 1em; }
#feedback-container { display: flex; flex-direction: column; gap: 1em; max-width: 300px; margin: 1em auto; }
.feedback-button { padding: 2em 1em; font-size: 1.2em; border: none; color: white; cursor: pointer; border-radius: 8px; text-align: center; }
.feedback-button.green { background-color: #2ecc71; }
.feedback-button.orange { background-color: #f39c12; }
.feedback-button.red { background-color: #e74c3c; }
#counters { margin-top: 1em; text-align: center; }
#counters span { font-weight: bold; }
""",
    base_path / 'public' / 'js' / 'config.js': """// NOTE: Normalement pas nécessaire si vous utilisez l'initialisation
// automatique de Firebase Hosting via /__/firebase/init.js
// Laissez ce fichier vide ou supprimez-le si vous utilisez l'init auto.

// const firebaseConfig = {
//   apiKey: "VOTRE_API_KEY", // NE PAS METTRE EN CLAIR DANS GIT SI REPO PUBLIC
//   authDomain: "VOTRE_PROJECT_ID.firebaseapp.com",
//   projectId: "VOTRE_PROJECT_ID",
//   storageBucket: "VOTRE_PROJECT_ID.appspot.com",
//   messagingSenderId: "VOTRE_SENDER_ID",
//   appId: "VOTRE_APP_ID"
// };

// // Initialiser Firebase (si pas via init.js)
// // firebase.initializeApp(firebaseConfig);
// // const db = firebase.firestore();
""",
    base_path / 'public' / 'js' / 'trainee.js': """console.log("Trainee JS Loaded");

// Récupérer l'ID de session depuis l'URL
const params = new URLSearchParams(window.location.search);
const sessionId = params.get('session');
const statusElement = document.getElementById('status');

if (!sessionId) {
    statusElement.textContent = "Erreur: ID de session manquant dans l'URL.";
    // Désactiver les boutons ?
} else {
    statusElement.textContent = `Session: ${sessionId}`;
    // TODO: Remplacer par l'URL de votre Cloud Function après déploiement
    // ou utiliser une fonction appelable si configurée.
    const voteFunctionUrl = 'VOTRE_URL_CLOUD_FUNCTION_VOTE_ICI'; // !!! IMPORTANT !!!

    document.querySelectorAll('.feedback-button').forEach(button => {
        button.addEventListener('click', () => {
            const color = button.dataset.color;
            statusElement.textContent = `Envoi du vote (${color})...`;
            button.disabled = true; // Empêcher double-clic

            fetch(voteFunctionUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ sessionId: sessionId, color: color })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Erreur HTTP ${response.status}`);
                }
                statusElement.textContent = `Vote (${color}) envoyé !`;
                // Optionnel : Réactiver après un délai, ou laisser désactivé ?
                setTimeout(() => {
                    button.disabled = false;
                    statusElement.textContent = `Session: ${sessionId} - Prêt à voter.`;
                }, 1500);
            })
            .catch(error => {
                console.error('Erreur lors de l\'envoi du vote:', error);
                statusElement.textContent = `Erreur lors de l'envoi (${color}). Réessayez.`;
                button.disabled = false; // Réactiver en cas d'erreur
            });
        });
    });
}
""",
    base_path / 'public' / 'js' / 'trainer.js': """console.log("Trainer JS Loaded");

// Récupérer l'ID de session depuis l'URL
const params = new URLSearchParams(window.location.search);
const sessionId = params.get('session');
const sessionIdElement = document.getElementById('sessionId');
const countGreenEl = document.getElementById('count-green');
const countOrangeEl = document.getElementById('count-orange');
const countRedEl = document.getElementById('count-red');
const countVotersEl = document.getElementById('count-voters');
// const countTraineesEl = document.getElementById('count-trainees');
// const participationRateEl = document.getElementById('participation-rate');
const ctx = document.getElementById('feedbackChart').getContext('2d');

let feedbackChart = null; // Variable pour stocker l'instance du graphique

function initializeChart() {
    feedbackChart = new Chart(ctx, {
        type: 'doughnut', // Type de graphique (doughnut ou pie)
        data: {
            labels: ['Vert', 'Orange', 'Rouge'],
            datasets: [{
                label: 'Votes',
                data: [0, 0, 0], // Données initiales
                backgroundColor: [
                    'rgba(46, 204, 113, 0.8)', // Vert
                    'rgba(243, 156, 18, 0.8)', // Orange
                    'rgba(231, 76, 60, 0.8)'   // Rouge
                ],
                borderColor: [
                    'rgba(46, 204, 113, 1)',
                    'rgba(243, 156, 18, 1)',
                    'rgba(231, 76, 60, 1)'
                ],
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
                legend: {
                    position: 'top',
                },
                title: {
                    display: true,
                    text: 'Répartition des Feedbacks'
                }
            }
        }
    });
}


if (!sessionId) {
    sessionIdElement.textContent = "ERREUR : ID de session manquant !";
    // Afficher un message d'erreur plus proéminent ?
} else {
    sessionIdElement.textContent = sessionId;
    initializeChart(); // Initialiser le graphique

    // S'assurer que le SDK Firebase est initialisé (via /__/firebase/init.js)
    // et que Firestore est disponible.
    try {
        const db = firebase.firestore(); // Utilise l'instance initialisée globalement
        const sessionRef = db.collection('sessions').doc(sessionId);

        console.log(`Écoute des changements pour la session: ${sessionId}`);

        sessionRef.onSnapshot((doc) => {
            console.log("Snapshot reçu:", doc.exists ? doc.data() : 'Document non trouvé');
            if (doc.exists) {
                const data = doc.data();
                const votes = data.voteCounts || { green: 0, orange: 0, red: 0 };
                const totalVoters = data.totalVoters || 0;
                // const totalTrainees = data.totalTrainees || 0; // Si implémenté

                // Mettre à jour les compteurs
                countGreenEl.textContent = votes.green;
                countOrangeEl.textContent = votes.orange;
                countRedEl.textContent = votes.red;
                countVotersEl.textContent = totalVoters;

                // Mettre à jour le graphique
                if (feedbackChart) {
                    feedbackChart.data.datasets[0].data = [votes.green, votes.orange, votes.red];
                    feedbackChart.update();
                }

                // Calculer et afficher le taux de participation (si totalTrainees est disponible)
                /*
                if (totalTrainees > 0) {
                    countTraineesEl.textContent = totalTrainees;
                    const rate = ((totalVoters / totalTrainees) * 100).toFixed(1);
                    participationRateEl.textContent = rate;
                } else {
                    countTraineesEl.textContent = 'N/A';
                    participationRateEl.textContent = 'N/A';
                }
                */

            } else {
                console.warn(`La session ${sessionId} n'existe pas dans Firestore.`);
                // Afficher un message indiquant que la session est invalide ou n'a pas encore de données
                countGreenEl.textContent = '-';
                countOrangeEl.textContent = '-';
                countRedEl.textContent = '-';
                countVotersEl.textContent = '0';
                if (feedbackChart) {
                     feedbackChart.data.datasets[0].data = [0, 0, 0];
                     feedbackChart.update();
                }
            }
        }, (error) => {
            console.error(`Erreur lors de l'écoute de la session ${sessionId}:`, error);
            // Afficher une erreur à l'utilisateur ?
        });

    } catch (e) {
        console.error("Erreur lors de l'initialisation de Firestore ou de l'écoute:", e);
        alert("Impossible de se connecter à la base de données de feedback. Vérifiez la configuration Firebase.");
    }
}

""",
    base_path / 'public' / 'service-worker.js': """// Nom du cache
const CACHE_NAME = 'feedback-pwa-cache-v1';
// URLs à mettre en cache (coquille applicative)
const urlsToCache = [
  '/', // Redirige souvent vers index.html
  '/index.html',
  '/trainee.html',
  '/trainer.html',
  '/css/style.css',
  // '/js/config.js', // Attention si contient des clés
  '/js/trainee.js',
  '/js/trainer.js',
  '/manifest.json',
  // '/assets/icons/icon-192x192.png', // Ajoutez les chemins réels vers vos icônes
  // '/assets/icons/icon-512x512.png'
  // Ne pas mettre en cache les scripts Firebase /__/firebase/... car gérés par Hosting
  // Ne pas mettre en cache Chart.js CDN ici si vous voulez la dernière version,
  // sinon téléchargez-le et ajoutez-le aux assets.
];

// Installation du Service Worker
self.addEventListener('install', event => {
  console.log('Service Worker: Installation');
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('Service Worker: Mise en cache de la coquille applicative');
        return cache.addAll(urlsToCache);
      })
      .catch(err => {
          console.error("Erreur de mise en cache initiale:", err);
      })
  );
});

// Activation du Service Worker
self.addEventListener('activate', event => {
  console.log('Service Worker: Activation');
  // Supprimer les anciens caches si nécessaire
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cache => {
          if (cache !== CACHE_NAME) {
            console.log('Service Worker: Suppression de l\'ancien cache', cache);
            return caches.delete(cache);
          }
        })
      );
    })
  );
  return self.clients.claim(); // Prend le contrôle immédiatement
});

// Interception des requêtes réseau (Fetch event)
self.addEventListener('fetch', event => {
  // Ne pas intercepter les requêtes vers les Cloud Functions ou Firestore
  if (event.request.url.includes('/__/firebase/')) {
      // Laisser passer les requêtes vers les services Firebase
      return;
  }
   if (event.request.method !== 'GET') {
       // Ne pas traiter les requêtes non-GET (ex: POST vers Cloud Function)
       return;
   }

  console.log('Service Worker: Fetching', event.request.url);
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Cache hit - retourner la réponse depuis le cache
        if (response) {
          console.log('Service Worker: Ressource trouvée dans le cache:', event.request.url);
          return response;
        }

        // Non trouvé dans le cache - aller sur le réseau
        console.log('Service Worker: Ressource non trouvée dans le cache, fetch réseau:', event.request.url);
        return fetch(event.request).then(
          networkResponse => {
            // Optionnel: Mettre en cache la nouvelle ressource récupérée ?
            // Attention avec les ressources externes ou dynamiques
            // if (networkResponse.ok && urlsToCache.includes(new URL(event.request.url).pathname)) {
            //   let responseToCache = networkResponse.clone();
            //   caches.open(CACHE_NAME).then(cache => {
            //       cache.put(event.request, responseToCache);
            //   });
            // }
            return networkResponse;
          }
        ).catch(error => {
            console.error("Service Worker: Erreur de fetch réseau:", error);
            // Optionnel: Retourner une page hors-ligne générique ?
            // return caches.match('/offline.html');
        });
      })
  );
});

""",
    # Fichiers que Firebase init crée mais qu'on assure ici
    base_path / 'firebase.json': """{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "functions": {
    "predeploy": [
      "npm --prefix \"$RESOURCE_DIR\" run lint"
    ],
    "source": "functions"
  },
  "hosting": {
    "public": "public",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "emulators": {
    "auth": {
      "port": 9099
    },
    "functions": {
      "port": 5001
    },
    "firestore": {
      "port": 8080
    },
    "hosting": {
      "port": 5000
    },
    "ui": {
      "enabled": true,
      "port": 4000
    }
  }
}
""",
    # Fichiers potentiellement utiles
    base_path / 'firestore.indexes.json': '{ "indexes": [], "fieldOverrides": [] }',
    base_path / 'functions' / 'package.json': """{
  "name": "functions",
  "description": "Cloud Functions for Firebase",
  "scripts": {
    "lint": "eslint .",
    "serve": "firebase emulators:start --only functions",
    "shell": "firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "index.js",
  "dependencies": {
    "firebase-admin": "^11.8.0",
    "firebase-functions": "^4.3.1"
  },
  "devDependencies": {
    "eslint": "^8.15.0",
    "eslint-config-google": "^0.14.0"
  },
  "private": true
}
""",
   base_path / 'functions' / 'index.js': """const functions = require("firebase-functions");
const admin = require("firebase-admin");

// Initialiser Firebase Admin SDK (une seule fois)
try {
  admin.initializeApp();
} catch (e) {
  console.log("Initialization failed or already initialized:", e.message);
}

const db = admin.firestore();

// // Exemple de fonction HTTP (à adapter pour la fonction 'vote')
// exports.helloWorld = functions.https.onRequest((request, response) => {
//   functions.logger.info("Hello logs!", {structuredData: true});
//   response.send("Hello from Firebase!");
// });


// TODO: Implémenter la fonction 'vote' ici
// Exemple de structure pour la fonction 'vote'
 exports.vote = functions
    // Optionnel: Définir la région (ex: europe-west1)
    // .region('europe-west1')
    .https.onRequest(async (req, res) => {
        // Autoriser les requêtes cross-origin (IMPORTANT pour le dev local et si le frontend n'est pas sur le même domaine/port)
        // TODO: Restreindre à votre domaine en production !
        res.set('Access-Control-Allow-Origin', '*');
        res.set('Access-Control-Allow-Methods', 'POST, GET, OPTIONS');
        res.set('Access-Control-Allow-Headers', 'Content-Type');

        // Gérer les requêtes OPTIONS (preflight)
        if (req.method === 'OPTIONS') {
            res.status(204).send('');
            return;
        }

        // Vérifier la méthode HTTP
        if (req.method !== 'POST') {
           res.status(405).send('Method Not Allowed');
           return;
        }

        // Récupérer les données du corps de la requête
        const { sessionId, color } = req.body;

        // Validation simple
        if (!sessionId || !color || !['green', 'orange', 'red'].includes(color)) {
            functions.logger.warn("Requête invalide reçue:", req.body);
            res.status(400).send('Invalid request body. Need sessionId and color (green, orange, red).');
            return;
        }

        functions.logger.info(`Vote reçu pour session ${sessionId}: ${color}`);

        const sessionRef = db.collection('sessions').doc(sessionId);

        try {
            await db.runTransaction(async (transaction) => {
                const sessionDoc = await transaction.get(sessionRef);

                let currentVotes = { green: 0, orange: 0, red: 0 };
                let currentTotalVoters = 0;

                if (sessionDoc.exists) {
                    currentVotes = sessionDoc.data().voteCounts || currentVotes;
                    currentTotalVoters = sessionDoc.data().totalVoters || 0;
                } else {
                    // Optionnel : Créer la session si elle n'existe pas ? Ou rejeter ?
                    // Pour l'instant, on crée implicitement les compteurs
                     functions.logger.info(`Session ${sessionId} non trouvée, création implicite.`);
                }

                // Incrémenter les compteurs
                const newVotes = { ...currentVotes };
                newVotes[color] = (newVotes[color] || 0) + 1;
                const newTotalVoters = currentTotalVoters + 1;

                // Mettre à jour le document
                // Utiliser set avec merge:true si on veut créer le doc s'il n'existe pas
                // Utiliser update si on est sûr qu'il existe (ou gérer l'erreur)
                transaction.set(sessionRef, {
                    voteCounts: newVotes,
                    totalVoters: newTotalVoters,
                    // Optionnel: ajouter/màj un timestamp de dernière activité
                    lastVoteAt: admin.firestore.FieldValue.serverTimestamp()
                 }, { merge: true }); // merge:true est important si le doc n'existe pas encore

                 functions.logger.info(`Session ${sessionId} mise à jour. Votes: ${JSON.stringify(newVotes)}, Total Votants: ${newTotalVoters}`);
            });

            res.status(204).send(); // Succès, pas de contenu à renvoyer

        } catch (error) {
            functions.logger.error(`Erreur lors de la transaction pour la session ${sessionId}:`, error);
            res.status(500).send('Internal Server Error');
        }
    });

""",
    base_path / 'functions' / '.gitignore': """# Dependency directories
node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Mac files
.DS_Store
""",
    base_path / '.firebaserc': '{} # Ce fichier sera rempli par `firebase use --add` ou `firebase init`',
}

print("\nCréation/Vérification des fichiers...")
for file_path, content in files_to_create_with_content.items():
    try:
        # Créer le dossier parent si nécessaire juste avant de créer le fichier
        file_path.parent.mkdir(parents=True, exist_ok=True)
        if not file_path.exists():
            file_path.write_text(content, encoding='utf-8')
            print(f"  [OK] Fichier créé : {file_path}")
        else:
            print(f"  [Skip] Fichier existe déjà : {file_path}")
            # Optionnel : Demander si on veut écraser ?
            # user_input = input(f"    Le fichier {file_path} existe. Écraser ? (o/N): ")
            # if user_input.lower() == 'o':
            #     file_path.write_text(content, encoding='utf-8')
            #     print(f"      Fichier écrasé.")
    except OSError as e:
        print(f"  [Erreur] Création fichier {file_path}: {e}")


print("\n--- Vérification terminée ---")
print("Structure de base créée/vérifiée.")
print("Conseils :")
print("1. Lancez `firebase init` si ce n'est pas déjà fait pour lier le projet.")
print("2. Exécutez `npm install` dans le dossier `functions/` pour installer les dépendances backend.")
print("3. Modifiez 'VOTRE_URL_CLOUD_FUNCTION_VOTE_ICI' dans `public/js/trainee.js` après le déploiement de la fonction.")
print("4. Configurez vos règles de sécurité Firestore (`firestore.rules`) avant toute utilisation réelle !")
